# My approach to the [Exactly Finance challenge](https://github.com/exactly-finance/challenge)

The project is divided into two sections: `Smart Contracts` & `Frontend`.

> The challenge does not explicitly require a frontend, however I've decided to add it anyway as an extra learning experience for myself.

## üßô‚Äç‚ôÇÔ∏è Tech used

-   `Smart Contracts`:
    -   Solidity - _Smart Contracts_
    -   ETH-Brownie - _Development Framework_
-   `Frontend`
    -   React - _UI Framework_ (WIP)
    -   Ethers.js - _Web3 Library_ (WIP)

---

## Index

-   [ü§î Thought Process](#process)
    -   [The Problem: Efficiency](#the-problem-efficiency)
    -   [Proposed Solution](#proposed-solution)
-   [üíª Set up](#set-up)
-   [üñ± Give it a try](#try)
-   [üìπ Showcase](#showcase)
-   [üìö Resources](#resources)

---

<a id="process"></a>

## ü§î Thought Process

Below is the thought process I took, and the way I decided to solve the challenge.

### Smart Contracts

As far as the description goes, only one contract is required, which is `ETHPool`.

It should allow:

-   (Public) Deposit _ETH_ staking.
-   (Public) Withdraw staked _ETH_.
-   (Public) Claim accumulated _ETH_ rewards.
-   (Public) Claim&Withdraw combined method.

--

-   (Owner) Deposit _ETH_ rewards.

--

-   (Read) Check user's staked _ETH_ balance.
-   (Read) Check contract's _ETH_ balance.

The reward system must:

-   Only transfer the _ETH_ rewards to the user when they claim it.
-   Reward calculation only takes into account the users in the pool at the time it is deposited by the owner.
-   More?

### The Problem: Efficiency

It is easy and intuitive to come up with a straight-forward solution that's able to distribute the rewards proportionally between all of the pool's participants whenever the rewards are deposited.

However, _in my opinion_, doing this would not be elegant at all, as it would require looping through all users and calculate their share every single time. In general - though specially in a blockchain context - this would make the transaction considerably **expensive** in terms of computational power, and **not scalable** as it would only get worse the more users are involved.

This is why I've opted to look for an alternative to try and solve this in a much more efficient way.

### Proposed Solution

> My approach to solve this problem is heavily inspired by the different [resources](#resources) found at the end of this file. However I had to come up with an adaptation in order to abide by the restrictions presented by this challenge.

There are two main factors to be considered in this problem:

-   Rewards are _sporadic_. There is no fixed interval between rewards. [(Why)](#domain-assumptions)
-   Rewards are not sent to the user until they claim them. This means that the rewards can't just be paid out whenever the deposit happens, but instead the solution needs to keep track of the corresponding rewards each user is entitled to. This is what's considered a **Pull-Based Reward Distribution**.

The way I've chosen to solve this problem consists of the use of **_Masks_**. These are used to represent the accumulated rewards generated by the contract up to a certain _period_ of time. Only two kinds of masks are stored:

-   `totalRewardPerTokenMask`: Only one value. Global.
-   `userRewardPerTokenMask`: Multiple. One per User.

An explanation will come further down, but jumping straight ahead for now, the solution for calculating the rewards of a User _u_ at period _n_ can be seen as:

![balance](readme-assets/general.png)

where:

-   u = User _u_.
-   p<sub>n</sub> = Period _n_.
-   B<sub>u, p<sub>n</sub></sub> = Balance of User _u_ at period _n_.
-   _S<sub>p<sub>n</sub></sub>_ = `totalRewardPerTokenMask` at period _n_.
-   _S<sub>u, p<sub>i</sub></sub>_ = Latest `userRewardPerTokenMask` of User _u_.

> In this problem's context, a **_Period_** is considered as passed whenever a new reward deposit is made.
>
> In a more realistic contract, a _Period_ would be some other kind of unit, like Blocks or Time.

These _S_ values contain all the needed reward distribution information, and would normally require a loop to be computed at the time of distribution. But in this situation, in order to guarantee efficiency, all calculations in the smart contract are done progressively as different interactions happen. These interactions can be divided into two types:

-   _User Interaction_:

    -   Updates user's accumulated rewards, if applicable.
    -   Updates user's mask to fit the new reward calculation. (_S<sub>u</sub>_)

-   _Admin Reward Interaction_:
    -   Signals the change of a _Period_, thus needing to update the total mask. (_S_)
    -   **[!]** Does not do any calculations related to the users.

Now, what are these _S_ values really?

Well, the _S_ value is an accumulator that contains all the reward history of the contract. It takes the rewards _R_ and distributes them between all the staked tokens in the pool at a certain time, _B<sub>T, p<sub>i</sub></sub>_ . That is:

![balance](readme-assets/Sgeneral.png)

And this is where the magic üßô‚Äç‚ôÇÔ∏è happens.

The strategy consists of avoiding having to go through the sum process on one go (loop), and instead calculate the next _S_ whenever a new period _p<sub>i</sub>_ begins, using the corresponding rewards _R_ and the current pool balance _B<sub>T, p<sub>i</sub></sub>_ , and accumulating the result into _S<sub>i-1</sub>_. That is:

![balance](readme-assets/Ssimplified.png)

> **[!]** This calculation is performed on every **_Admin Reward Interaction_**

So _S_ contains the total reward per staked token from the very beginning until the current period. In other words, we can use _S_ to know how many rewards each token is worth from the start of the rewards, and thus can calculate the corresponding rewards each user is entitled to by using their balance.

Another thing missing is some way to "tag" the moment from which the user has rights to claim part of those total rewards. This is where _S<sub>u</sub>_ comes in; a variable that denotes the amount of _S_ rewards that don't belong to User _u_. Subtracting it does the job here, as it will take out any previous rewards the pool has produced until the current period, and allow for any upcoming ones to count towards the user pending rewards.

Last step is to always override User _u_'s latest mask _S<sub>u, p<sub>i</sub></sub>_, whenever their rewards are calculated; with the current total mask: _S<sub>u, p<sub>i</sub></sub>_ = _S<sub>u, p<sub>n</sub></sub>_

--

Looking back at the full formula:

![balance](readme-assets/general.png)

> **[!]** This calculation is performed on every **_User Interaction_**

We can now see that all values are present when _p<sub>n</sub>_ is the current period, since they have been being gradually calculated throughout the contract's lifetime.

### _And this is how reward calculation can be done in an efficient way, avoiding loops and thus reducing gas consumption._ üî•

<br/>

> ### Domain Assumptions
>
> -   **ERC-20 Reward Token**: For the sake of making it slightly more interesting, I've decided to make the reward token an ERC-20 instead of just ETH.
> -   **Sporadic Rewards**: I'm assuming the "weekly" rewards mentioned in the challenge's description were just an example. My understanding is that there wouldn't be an actual **fixed** interval if the rewards are handled manually by the contract's admin. Thus this leads me to believe the reward deposits themselves can happen at any desired time.
>     -   A much more realistic staking contract would likely implement their rewards with a fix rate per block, or time; Implementing these are far easier with the method I use, though I was able to adapt it successfully.
> -   **Dynamic Reward Amount**: The amount of rewards to be distributed when a deposit happens can be any amount with no restrictions.
> -   **The Owner is the Admin**: For simplicity, the admin in charge of the rewards is the owner itself.
>     -   This could easily be extended to allow more than one people, aka, create a _Team_ role instead.

<a id="set-up"></a>

## üíª Set up

TODO :)

<a id="try"></a>

## üñ± Give it a try

TODO :)

<a id="showcase"></a>

## üìπ Showcase

TODO :)

<a id="resources"></a>

## üìö Resources

> ### Smart Contract Solution
>
> -   Paper _"Scalable Reward Distribution on the Ethereum Blockchain"_ by Bogdan Batog, Lucian Boca, Nick Johnson.
>
> -   EIP-1973 [Scalable Rewards](https://eips.ethereum.org/EIPS/eip-1973).
>
> -   Scalable implementation of the [Synthetix Reward System](https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol), despite not being completely applicable to this challenge's requirements.
>
> -   [Scalable Reward Distribution with Changing Stake Sizes](https://solmaz.io/2019/02/24/scalable-reward-changing/), Solmaz.io.
