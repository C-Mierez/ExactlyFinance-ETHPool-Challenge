# My approach to the [Exactly Finance challenge](https://github.com/exactly-finance/challenge)

The project is divided into two sections: `Smart Contracts` & `Frontend`.

> The challenge does not explicitly require a frontend, however I've decided to add it anyway as an extra learning experience for myself.

## 🧙‍♂️ Tech used

-   `Smart Contracts`:
    -   Solidity - _Smart Contracts_
    -   ETH-Brownie - _Development Framework_
-   `Frontend`
    -   React - _UI Framework_
    -   Ethers.js - _Web3 Library_

---

## Index

-   [🤔 Thought Process](#🤔-thought-process)
    -   [The Problem: Efficiency](#the-problem-efficiency)
    -   [Proposed Solution](#proposed-solution)
-   [💻 Set up](#💻-set-up)
-   [🖱 Give it a try](#🖱-give-it-a-try)
-   [📹 Showcase](#📹-showcase)
-   [📚 Resources](#📚-resources)

---

## 🤔 Thought Process

Below is the thought process I took, and the way I decided to solve the challenge.

### Smart Contracts

As far as the description goes, only one contract is required, which is `ETHPool`.

It should allow:

-   (Public) Deposit _ETH_ staking.
-   (Public) Withdraw staked _ETH_.
-   (Public) Claim accumulated _ETH_ rewards.
-   (Public) Claim&Withdraw combined method.

--

-   (Owner) Deposit _ETH_ rewards.

--

-   (Read) Check user's staked _ETH_ balance.
-   (Read) Check contract's _ETH_ balance.

The reward system must:

-   Only transfer the _ETH_ rewards to the user when they claim it.
-   Reward calculation only takes into account the users in the pool at the time it is deposited by the owner.
-   More?

### The Problem: Efficiency

It is easy and intuitive to come up with a straight-forward solution that's able to distribute the rewards proportionally between all of the pool's participants whenever the rewards are deposited.

However, _in my opinion_, doing this would not be elegant at all, as it would require looping through all users and calculate their share every single time. In general - though specially in a blockchain context - this would make the transaction considerably **expensive** in terms of computational power, and **not scalable** as it would only get worse the more users are involved.

This is why I've opted to look for an alternative to try and solve this in a much more efficient way.

### Proposed Solution

> My approach to solve this problem is heavily inspired by the different [resources](#📚-resources) found at the end of this file. However I had to come up with an adaptation in order to abide by the restrictions presented by this challenge.

There are two main factors to be considered in this problem:

-   Rewards are _sporadic_. There is no fixed interval between rewards. [(Why)](#domain-assumptions)
-   Rewards are not sent to the user until they claim them. This means that the rewards can't just be paid out whenever the deposit happens, but instead the solution needs to keep track of the corresponding rewards each user is entitled to.

The way I've chosen to solve this problem consists of the use of **_Masks_**. These are be used to represent the accumulated rewards generated by the contract up to a certain _period_ of time. Only two kinds of masks are stored:

-   `totalRewardPerTokenMask`: Only one value. Global.
-   `userRewardPerTokenMask`: Multiple. One per User.

In this problem's context, a **_Period_** is considered as passed whenever a new reward deposit is made.

![balance](readme-assets/period.png)

> In a more realistic contract, a _Period_ would be some other kind of unit, like Blocks or Time.

We must also keep track of the user's balances and the total pool balance:

![balance](readme-assets/totalbalance.png)

![balance](readme-assets/userbalance.png)

When a _period_ passes, the `totalRewardPerTokenMask` is updated by accumulating the newest rewards distributed between the total amount of tokens staked. This is:

> ### Domain Assumptions
>
> -   **ERC-20 Reward Token**: For the sake of making it slightly more interesting, I've decided to make the reward token an ERC-20 instead of just ETH.
> -   **Sporadic Rewards**: I'm assuming the "weekly" rewards mentioned in the challenge's description were just an example. My understanding is that there wouldn't be an actual **fixed** interval if the rewards are handled manually by the contract's admin. Thus this leads me to believe the reward deposits themselves can happen at any desired time.
>     -   A much more realistic staking contract would likely implement their rewards with a fix rate per block, or time; Implementing these are far easier with the method I use, though I was able to adapt it successfully.
> -   **Dynamic Reward Amount**: The amount of rewards to be distributed when a deposit happens can be any amount with no restrictions.
> -   **The Owner is the Admin**: For simplicity, the admin in charge of the rewards is the owner itself.
>     -   This could easily be extended to allow more than one people, aka, create a _Team_ role instead.
> -   TODO :)

## 💻 Set up

TODO :)

## 🖱 Give it a try

TODO :)

## 📹 Showcase

TODO :)

## 📚 Resources

> ### Smart Contract Solution
>
> -   Paper _"Scalable Reward Distribution on the Ethereum Blockchain"_ by Bogdan Batog, Lucian Boca, Nick Johnson.
>
> -   EIP-1973 [Scalable Rewards](https://eips.ethereum.org/EIPS/eip-1973).
>
> -   Scalable implementation of the [Synthetix Reward System](https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol), despite not being completely applicable to this challenge's requirements.
>
> -   [Scalable Reward Distribution with Changing Stake Sizes](https://solmaz.io/2019/02/24/scalable-reward-changing/), Solmaz.io.
